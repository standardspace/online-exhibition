/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./assets/js/entry.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./assets/js/build/polyfills.js":
/*!**************************************!*\
  !*** ./assets/js/build/polyfills.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * Polyfill for object fit css properties.
 * Requires Modernizr detection feature to detect wether the browser supports Object Fit
 * 
 * Usage:
 * Wrap your object fit image in a div or other block element and give it a class of .ob-image
 * The image URL will be applied to the wrapping element as a background-image.
*/
if (!Modernizr.objectfit) {
  var imgContainer = document.querySelectorAll('.ob-image');
  imgContainer.forEach(function (el) {
    var imgURL = el.querySelector('img').src;

    if (imgURL) {
      el.style.backgroundImage = "url('".concat(imgURL, "')");
      el.classList.add('ob-image--active');
    }
  });
}

;

/***/ }),

/***/ "./assets/js/build/script.js":
/*!***********************************!*\
  !*** ./assets/js/build/script.js ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lays.js */ "./node_modules/lays.js/dist/lays.cjs.js");
/* harmony import */ var lays_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lays_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var a11y_dialog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! a11y-dialog */ "./node_modules/a11y-dialog/dist/a11y-dialog.esm.js");
// Go wild...
// import Macy from "macy";



var inViewport = __webpack_require__(/*! in-viewport */ "./node_modules/in-viewport/in-viewport.js");

var maGallery = document.querySelector('.ma-gallery');

if (maGallery) {
  // Grid the gallery
  // const maGalleryGrid = Macy({
  //   container: maGallery,
  //   trueOrder: true,
  //   waitForImages: false,
  //   mobileFirst: true,
  //   margin: 8,
  //   columns: 1,
  //   breakAt: {
  //     520: {
  //       margin: 16,
  //       columns: 2
  //     },
  //     1024: {
  //       margin: 32,
  //       columns: 3
  //     },
  //     1440: {
  //       margin: 48,
  //       columns: 4
  //     }
  //   }
  // });
  var lays = lays_js__WEBPACK_IMPORTED_MODULE_0___default()({
    parent: maGallery,
    prependItems: false,
    maxItems: Infinity,
    breakpoints: {
      576: 2,
      768: 2,
      992: 3,
      1200: 4
    }
  });
  lays.render(); // Gallery modal

  var galleryItems = maGallery.querySelectorAll('.ma-gallery__item');
  var modalArtworks = '';
  var iconChevronLeft = "<svg \n    xmlns=\"http://www.w3.org/2000/svg\"\n    focusable=\"false\"\n    height=\"24px\" \n    viewBox=\"0 0 24 24\" \n    width=\"24px\" \n    fill=\"#000000\">\n      <path d=\"M0 0h24v24H0z\" fill=\"none\"/><path d=\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\"/>\n    </svg>";
  var iconChevronRight = "<svg \n    xmlns=\"http://www.w3.org/2000/svg\"\n    focusable = \"false\"\n    height=\"24px\" \n    viewBox=\"0 0 24 24\" \n    width=\"24px\" \n    fill=\"#000000\">\n      <path d=\"M0 0h24v24H0z\" fill=\"none\"/><path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"/>\n    </svg>"; // Create Modal Content

  galleryItems.forEach(function (item, idx) {
    var itemTitle = item.querySelector('.ma-gallery__item__title').innerText;
    var imageFullPath = item.dataset.imageFull;
    var itemLink = item.querySelector('.ma-gallery__item__link').getAttribute('href');
    var itemArtist = item.dataset.artist;
    var itemArtistUrl = item.dataset.artistUrl;
    var itemPostId = item.dataset.postId; // Get a link and add

    modalArtworks += "\n    <li class=\"ma-gallery-scroller__item\" id=\"ma-gallery-scroll-item-".concat(idx, "\" data-post-id=\"").concat(itemPostId, "\">\n      <figure class=\"ma-gallery-scroller__item__figure\">\n        <img class=\"ma-gallery-scroller__item__image\" src=\"").concat(imageFullPath, "\" alt=\"Artwork: ").concat(itemTitle, "\" loading=\"lazy\" />\n        <figcaption class=\"ma-gallery-scroller__item__title\">\n          <a href=\"").concat(itemLink, "\">").concat(itemTitle, "</a> \n          by <a href=\"").concat(itemArtistUrl, "\">").concat(itemArtist, "</a>\n        </figcaption>\n      </figure>\n    </li>");
  }); // modal markup

  var modal = document.createElement('div');
  modal.classList.add('dialog');
  modal.id = "my-dialog";
  modal.setAttribute('aria-hidden', true);
  modal.innerHTML = "<div class=\"dialog-overlay\" tabindex=\"-1\" data-a11y-dialog-hide></div>\n    <div\n      role=\"dialog\"\n      class=\"dialog-content\"\n      aria-label=\"Gallery artwork viewer\"\n    >\n      <button\n        data-a11y-dialog-hide\n        class=\"dialog-close\"\n        aria-label=\"Close this dialog window\"\n      >\n        &times;\n      </button>\n\n      <ul class=\"ma-gallery-scroller\">\n        ".concat(modalArtworks, "\n      </ul>\n      <div class=\"ma-gallery-scroller-nav\"> \n        <button class=\"ma-gallery-scroller-nav__prev\"><span class=\"sr-only\">Previous</span>").concat(iconChevronLeft, "</button>\n        <button class=\"ma-gallery-scroller-nav__next\"><span class=\"sr-only\">Next</span>").concat(iconChevronRight, "</button>\n      </div>\n\n    </div>");
  document.body.appendChild(modal);
  var dialogEl = document.getElementById('my-dialog');
  var mainEl = document.querySelector('main');
  var dialog = new a11y_dialog__WEBPACK_IMPORTED_MODULE_1__["default"](dialogEl, mainEl);
  dialog.on('show', function (dialogEl, triggerEl) {
    // console.log(dialogEl)
    // console.log(triggerEl)
    var galleryScroller = dialogEl.querySelector('.ma-gallery-scroller');
    var galleryItems = galleryScroller.querySelectorAll('.ma-gallery-scroller__item'); // console.log(galleryScroller)

    var buttonPrev = dialogEl.querySelector('.ma-gallery-scroller-nav__prev');
    var buttonNext = dialogEl.querySelector('.ma-gallery-scroller-nav__next');

    var navigateScroller = function navigateScroller(evt, type) {
      galleryItems.forEach(function (item, idx) {
        var currentVisible = inViewport(item, {
          container: galleryScroller,
          offset: -100
        });

        if (currentVisible) {
          var targetElIdx = type === "next" ? idx + 1 : idx - 1;
          galleryItems[targetElIdx].scrollIntoView({
            behavior: "smooth"
          });
        }
      });
    };

    buttonPrev.addEventListener("click", function (evt) {
      navigateScroller(evt, 'prev');
    });
    buttonNext.addEventListener("click", function (evt) {
      navigateScroller(evt, 'next');
    }); // Listen for scroll events as we;ll need to 
    // disable buttons when scroll reaches beginning or end
    // Setup isScrolling variable

    var isScrolling;
    galleryScroller.addEventListener('scroll', function (event) {
      // Clear our timeout throughout the scroll
      window.clearTimeout(isScrolling); // Set a timeout to run after scrolling ends

      isScrolling = setTimeout(function () {
        // Run the callback
        galleryItems.forEach(function (item, idx) {
          var currentVisible = inViewport(item, {
            container: galleryScroller,
            offset: -100
          });

          if (currentVisible) {
            // Disable button if reached beginning or end
            if (galleryItems.length - 1 === idx) {
              console.log('end of the line');
              buttonPrev.disabled = false;
              buttonNext.disabled = true;
            } else if (idx === 0) {
              console.log('start of the line');
              buttonPrev.disabled = true;
              buttonNext.disabled = false;
            } else {
              buttonPrev.disabled = false;
              buttonNext.disabled = false;
            } // Update url hash


            var itemPostId = item.dataset.postId; // history.pushState(null, null, '#item-' + itemPostId);

            history.replaceState(null, null, '#item-' + itemPostId);
          }
        });
      }, 66);
    }, false);
  });
  dialog.on('hide', function () {
    console.log('dialog closed');
    location.hash = "";
    history.replaceState("", "", location.pathname);
  });
  galleryItems.forEach(function (galleryItem, idx) {
    var imageFullPath = galleryItem.dataset.imageFull;
    var itemHeading = galleryItem.querySelector('.ma-gallery__item__title');
    var link = itemHeading.querySelector('.ma-gallery__item__link');
    var linkInner = link.innerHTML;
    galleryItem.dataset.itemIndex = idx; // Swap link for button

    itemHeading.innerHTML = "<button class=\"ma-gallery__item__button\" data-a11y-dialog-show=\"my-dialog\">".concat(linkInner, "</button>");
    var itemButton = itemHeading.querySelector('.ma-gallery__item__button');

    itemButton.onclick = function () {
      var itemIndex = galleryItem.dataset.itemIndex;
      var targetItem = document.getElementById('ma-gallery-scroll-item-' + itemIndex); // Open gallery modal

      dialog.show(); // Re-enable buttons (they may have been disable in previous opening)

      var buttonPrev = dialogEl.querySelector('.ma-gallery-scroller-nav__prev');
      var buttonNext = dialogEl.querySelector('.ma-gallery-scroller-nav__next');
      buttonPrev.disabled = false;
      buttonNext.disabled = false; // Scroll to clicked item

      targetItem.scrollIntoView(); // Disable previous button if first item

      if (itemIndex == 0) {
        buttonPrev.disabled = true;
      }
    };
  }); // Open on hash link

  if (window.location.hash && window.location.hash.startsWith('#item-')) {
    var itemToOpenPostId = window.location.hash.replace('#item-', '');
    var itemToOpen = document.querySelector("[data-post-id=\"".concat(itemToOpenPostId, "\"]"));

    if (itemToOpen) {
      var itemToOpenButton = itemToOpen.querySelector('button'); // Button focus 

      itemToOpenButton.focus(); // Button click

      itemToOpenButton.click();
    }
  }
} // Artwork series dialog


var artworkSeriesDialogEl = document.getElementById('dialog-artwork-series'); // var mainEl = document.querySelector('main')

if (artworkSeriesDialogEl) {
  var artworkSeriesDialog = new a11y_dialog__WEBPACK_IMPORTED_MODULE_1__["default"](artworkSeriesDialogEl, mainEl);
  var buttonArtworkSeriesDialog = document.getElementById('dialog-artwork-series-open');
  buttonArtworkSeriesDialog.addEventListener('click', function () {
    artworkSeriesDialog.show(); // Re-enable buttons (they may have been disable in previous opening)

    var buttonPrev = artworkSeriesDialogEl.querySelector('.ma-gallery-scroller-nav__prev');
    var buttonNext = artworkSeriesDialogEl.querySelector('.ma-gallery-scroller-nav__next');
    buttonPrev.disabled = false;
    buttonNext.disabled = false;
  });
  artworkSeriesDialog.on('show', function (artworkSeriesDialogEl, triggerEl) {
    // console.log(dialogEl)
    // console.log(triggerEl)
    var galleryScroller = artworkSeriesDialogEl.querySelector('.ma-gallery-scroller');
    var galleryItems = galleryScroller.querySelectorAll('.ma-gallery-scroller__item'); // console.log(galleryScroller)

    var buttonPrev = artworkSeriesDialogEl.querySelector('.ma-gallery-scroller-nav__prev');
    var buttonNext = artworkSeriesDialogEl.querySelector('.ma-gallery-scroller-nav__next');

    var navigateScroller = function navigateScroller(evt, type) {
      galleryItems.forEach(function (item, idx) {
        var currentVisible = inViewport(item, {
          container: galleryScroller,
          offset: -100
        });

        if (currentVisible) {
          var targetElIdx = type === "next" ? idx + 1 : idx - 1;
          galleryItems[targetElIdx].scrollIntoView({
            behavior: "smooth"
          });
        }
      });
    };

    buttonPrev.addEventListener("click", function (evt) {
      navigateScroller(evt, 'prev');
    });
    buttonNext.addEventListener("click", function (evt) {
      navigateScroller(evt, 'next');
    }); // Listen for scroll events as we;ll need to 
    // disable buttons when scroll reaches beginning or end
    // Setup isScrolling variable

    var isScrolling;
    galleryScroller.addEventListener('scroll', function (event) {
      // Clear our timeout throughout the scroll
      window.clearTimeout(isScrolling); // Set a timeout to run after scrolling ends

      isScrolling = setTimeout(function () {
        // Run the callback
        galleryItems.forEach(function (item, idx) {
          var currentVisible = inViewport(item, {
            container: galleryScroller,
            offset: -200
          });

          if (currentVisible) {
            // Disable button if reached beginning or end
            if (galleryItems.length - 1 === idx) {
              console.log('end of the line');
              buttonPrev.disabled = false;
              buttonNext.disabled = true;
            } else if (idx === 0) {
              console.log('start of the line');
              buttonPrev.disabled = true;
              buttonNext.disabled = false;
            } else {
              buttonPrev.disabled = false;
              buttonNext.disabled = false;
            }
          }
        });
      }, 66);
    }, false);
  });
}

/***/ }),

/***/ "./assets/js/entry.js":
/*!****************************!*\
  !*** ./assets/js/entry.js ***!
  \****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _build_polyfills_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./build/polyfills.js */ "./assets/js/build/polyfills.js");
/* harmony import */ var _build_polyfills_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_build_polyfills_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _build_script_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./build/script.js */ "./assets/js/build/script.js");
/* harmony import */ var _sass_style_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../sass/style.scss */ "./assets/sass/style.scss");
/* harmony import */ var _sass_style_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_sass_style_scss__WEBPACK_IMPORTED_MODULE_2__);
/*
 * Webpack Entry Point.
*/
// Scripts

 // Styles



/***/ }),

/***/ "./assets/sass/style.scss":
/*!********************************!*\
  !*** ./assets/sass/style.scss ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/a11y-dialog/dist/a11y-dialog.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/a11y-dialog/dist/a11y-dialog.esm.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return A11yDialog; });
var focusableSelectors = [
  'a[href]:not([tabindex^="-"])',
  'area[href]:not([tabindex^="-"])',
  'input:not([type="hidden"]):not([type="radio"]):not([disabled]):not([tabindex^="-"])',
  'input[type="radio"]:not([disabled]):not([tabindex^="-"])',
  'select:not([disabled]):not([tabindex^="-"])',
  'textarea:not([disabled]):not([tabindex^="-"])',
  'button:not([disabled]):not([tabindex^="-"])',
  'iframe:not([tabindex^="-"])',
  'audio[controls]:not([tabindex^="-"])',
  'video[controls]:not([tabindex^="-"])',
  '[contenteditable]:not([tabindex^="-"])',
  '[tabindex]:not([tabindex^="-"])',
];

var TAB_KEY = 9;
var ESCAPE_KEY = 27;

/**
 * Define the constructor to instantiate a dialog
 *
 * @constructor
 * @param {Element} element
 */
function A11yDialog(element) {
  // Prebind the functions that will be bound in addEventListener and
  // removeEventListener to avoid losing references
  this._show = this.show.bind(this);
  this._hide = this.hide.bind(this);
  this._maintainFocus = this._maintainFocus.bind(this);
  this._bindKeypress = this._bindKeypress.bind(this);

  this.$el = element;
  this.shown = false;
  this._id = this.$el.getAttribute('data-a11y-dialog') || this.$el.id;
  this._previouslyFocused = null;
  this._listeners = {};

  // Initialise everything needed for the dialog to work properly
  this.create();
}

/**
 * Set up everything necessary for the dialog to be functioning
 *
 * @param {(NodeList | Element | string)} targets
 * @return {this}
 */
A11yDialog.prototype.create = function () {
  this.$el.setAttribute('aria-hidden', true);
  this.$el.setAttribute('aria-modal', true);
  this.$el.setAttribute('tabindex', -1);

  if (!this.$el.hasAttribute('role')) {
    this.$el.setAttribute('role', 'dialog');
  }

  // Keep a collection of dialog openers, each of which will be bound a click
  // event listener to open the dialog
  this._openers = $$('[data-a11y-dialog-show="' + this._id + '"]');
  this._openers.forEach(
    function (opener) {
      opener.addEventListener('click', this._show);
    }.bind(this)
  );

  // Keep a collection of dialog closers, each of which will be bound a click
  // event listener to close the dialog
  this._closers = $$('[data-a11y-dialog-hide]', this.$el).concat(
    $$('[data-a11y-dialog-hide="' + this._id + '"]')
  );
  this._closers.forEach(
    function (closer) {
      closer.addEventListener('click', this._hide);
    }.bind(this)
  );

  // Execute all callbacks registered for the `create` event
  this._fire('create');

  return this
};

/**
 * Show the dialog element, disable all the targets (siblings), trap the
 * current focus within it, listen for some specific key presses and fire all
 * registered callbacks for `show` event
 *
 * @param {CustomEvent} event
 * @return {this}
 */
A11yDialog.prototype.show = function (event) {
  // If the dialog is already open, abort
  if (this.shown) {
    return this
  }

  // Keep a reference to the currently focused element to be able to restore
  // it later
  this._previouslyFocused = document.activeElement;
  this.$el.removeAttribute('aria-hidden');
  this.shown = true;

  // Set the focus to the dialog element
  moveFocusToDialog(this.$el);

  // Bind a focus event listener to the body element to make sure the focus
  // stays trapped inside the dialog while open, and start listening for some
  // specific key presses (TAB and ESC)
  document.body.addEventListener('focus', this._maintainFocus, true);
  document.addEventListener('keydown', this._bindKeypress);

  // Execute all callbacks registered for the `show` event
  this._fire('show', event);

  return this
};

/**
 * Hide the dialog element, enable all the targets (siblings), restore the
 * focus to the previously active element, stop listening for some specific
 * key presses and fire all registered callbacks for `hide` event
 *
 * @param {CustomEvent} event
 * @return {this}
 */
A11yDialog.prototype.hide = function (event) {
  // If the dialog is already closed, abort
  if (!this.shown) {
    return this
  }

  this.shown = false;
  this.$el.setAttribute('aria-hidden', 'true');

  // If there was a focused element before the dialog was opened (and it has a
  // `focus` method), restore the focus back to it
  // See: https://github.com/KittyGiraudel/a11y-dialog/issues/108
  if (this._previouslyFocused && this._previouslyFocused.focus) {
    this._previouslyFocused.focus();
  }

  // Remove the focus event listener to the body element and stop listening
  // for specific key presses
  document.body.removeEventListener('focus', this._maintainFocus, true);
  document.removeEventListener('keydown', this._bindKeypress);

  // Execute all callbacks registered for the `hide` event
  this._fire('hide', event);

  return this
};

/**
 * Destroy the current instance (after making sure the dialog has been hidden)
 * and remove all associated listeners from dialog openers and closers
 *
 * @return {this}
 */
A11yDialog.prototype.destroy = function () {
  // Hide the dialog to avoid destroying an open instance
  this.hide();

  // Remove the click event listener from all dialog openers
  this._openers.forEach(
    function (opener) {
      opener.removeEventListener('click', this._show);
    }.bind(this)
  );

  // Remove the click event listener from all dialog closers
  this._closers.forEach(
    function (closer) {
      closer.removeEventListener('click', this._hide);
    }.bind(this)
  );

  // Execute all callbacks registered for the `destroy` event
  this._fire('destroy');

  // Keep an object of listener types mapped to callback functions
  this._listeners = {};

  return this
};

/**
 * Register a new callback for the given event type
 *
 * @param {string} type
 * @param {Function} handler
 */
A11yDialog.prototype.on = function (type, handler) {
  if (typeof this._listeners[type] === 'undefined') {
    this._listeners[type] = [];
  }

  this._listeners[type].push(handler);

  return this
};

/**
 * Unregister an existing callback for the given event type
 *
 * @param {string} type
 * @param {Function} handler
 */
A11yDialog.prototype.off = function (type, handler) {
  var index = (this._listeners[type] || []).indexOf(handler);

  if (index > -1) {
    this._listeners[type].splice(index, 1);
  }

  return this
};

/**
 * Iterate over all registered handlers for given type and call them all with
 * the dialog element as first argument, event as second argument (if any). Also
 * dispatch a custom event on the DOM element itself to make it possible to
 * react to the lifecycle of auto-instantiated dialogs.
 *
 * @access private
 * @param {string} type
 * @param {CustomEvent} event
 */
A11yDialog.prototype._fire = function (type, event) {
  var listeners = this._listeners[type] || [];
  var domEvent = new CustomEvent(type, { detail: event });

  this.$el.dispatchEvent(domEvent);

  listeners.forEach(
    function (listener) {
      listener(this.$el, event);
    }.bind(this)
  );
};

/**
 * Private event handler used when listening to some specific key presses
 * (namely ESCAPE and TAB)
 *
 * @access private
 * @param {Event} event
 */
A11yDialog.prototype._bindKeypress = function (event) {
  // This is an escape hatch in case there are nested dialogs, so the keypresses
  // are only reacted to for the most recent one
  if (!this.$el.contains(document.activeElement)) return

  // If the dialog is shown and the ESCAPE key is being pressed, prevent any
  // further effects from the ESCAPE key and hide the dialog, unless its role
  // is 'alertdialog', which should be modal
  if (
    this.shown &&
    event.which === ESCAPE_KEY &&
    this.$el.getAttribute('role') !== 'alertdialog'
  ) {
    event.preventDefault();
    this.hide(event);
  }

  // If the dialog is shown and the TAB key is being pressed, make sure the
  // focus stays trapped within the dialog element
  if (this.shown && event.which === TAB_KEY) {
    trapTabKey(this.$el, event);
  }
};

/**
 * Private event handler used when making sure the focus stays within the
 * currently open dialog
 *
 * @access private
 * @param {Event} event
 */
A11yDialog.prototype._maintainFocus = function (event) {
  // If the dialog is shown and the focus is not within a dialog element (either
  // this one or another one in case of nested dialogs) or within an element
  // with the `data-a11y-dialog-focus-trap-ignore` attribute, move it back to
  // its first focusable child.
  // See: https://github.com/KittyGiraudel/a11y-dialog/issues/177
  if (
    this.shown &&
    !event.target.closest('[aria-modal="true"]') &&
    !event.target.closest('[data-a11y-dialog-ignore-focus-trap]')
  ) {
    moveFocusToDialog(this.$el);
  }
};

/**
 * Convert a NodeList into an array
 *
 * @param {NodeList} collection
 * @return {Array<Element>}
 */
function toArray(collection) {
  return Array.prototype.slice.call(collection)
}

/**
 * Query the DOM for nodes matching the given selector, scoped to context (or
 * the whole document)
 *
 * @param {String} selector
 * @param {Element} [context = document]
 * @return {Array<Element>}
 */
function $$(selector, context) {
  return toArray((context || document).querySelectorAll(selector))
}

/**
 * Set the focus to the first element with `autofocus` with the element or the
 * element itself
 *
 * @param {Element} node
 */
function moveFocusToDialog(node) {
  var focused = node.querySelector('[autofocus]') || node;

  focused.focus();
}

/**
 * Get the focusable children of the given element
 *
 * @param {Element} node
 * @return {Array<Element>}
 */
function getFocusableChildren(node) {
  return $$(focusableSelectors.join(','), node).filter(function (child) {
    return !!(
      child.offsetWidth ||
      child.offsetHeight ||
      child.getClientRects().length
    )
  })
}

/**
 * Trap the focus inside the given element
 *
 * @param {Element} node
 * @param {Event} event
 */
function trapTabKey(node, event) {
  var focusableChildren = getFocusableChildren(node);
  var focusedItemIndex = focusableChildren.indexOf(document.activeElement);

  // If the SHIFT key is being pressed while tabbing (moving backwards) and
  // the currently focused item is the first one, move the focus to the last
  // focusable item from the dialog element
  if (event.shiftKey && focusedItemIndex === 0) {
    focusableChildren[focusableChildren.length - 1].focus();
    event.preventDefault();
    // If the SHIFT key is not being pressed (moving forwards) and the currently
    // focused item is the last one, move the focus to the first focusable item
    // from the dialog element
  } else if (
    !event.shiftKey &&
    focusedItemIndex === focusableChildren.length - 1
  ) {
    focusableChildren[0].focus();
    event.preventDefault();
  }
}

function instantiateDialogs() {
  $$('[data-a11y-dialog]').forEach(function (node) {
    new A11yDialog(node);
  });
}

if (typeof document !== 'undefined') {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', instantiateDialogs);
  } else {
    if (window.requestAnimationFrame) {
      window.requestAnimationFrame(instantiateDialogs);
    } else {
      window.setTimeout(instantiateDialogs, 16);
    }
  }
}




/***/ }),

/***/ "./node_modules/in-viewport/in-viewport.js":
/*!*************************************************!*\
  !*** ./node_modules/in-viewport/in-viewport.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = inViewport;

var instances = [];
var supportsMutationObserver = typeof global.MutationObserver === 'function';

function inViewport(elt, params, cb) {
  var opts = {
    container: global.document.body,
    offset: 0,
    debounce: 15,
    failsafe: 150
  };

  if (params === undefined || typeof params === 'function') {
    cb = params;
    params = {};
  }

  var container = opts.container = params.container || opts.container;
  var offset = opts.offset = params.offset || opts.offset;
  var debounceValue = opts.debounce = params.debounce || opts.debounce;
  var failsafe = opts.failsafe = params.failsafe || opts.failsafe;

  // ensure backward compatibility with failsafe as boolean
  if (failsafe === true) {
    failsafe = 150;
  } else if(failsafe === false) {
    failsafe = 0;
  }

  // failsafe check always needs to be higher than debounceValue
  if (failsafe > 0 && failsafe < debounceValue) {
      failsafe = debounceValue + 50;
  }

  for (var i = 0; i < instances.length; i++) {
    if (
      instances[i].container === container &&
      instances[i]._debounce === debounceValue &&
      instances[i]._failsafe === failsafe
    ) {
      return instances[i].isInViewport(elt, offset, cb);
    }
  }

  return instances[
    instances.push(createInViewport(container, debounceValue, failsafe)) - 1
  ].isInViewport(elt, offset, cb);
}

function addEvent(el, type, fn) {
  if (el.attachEvent) {
    el.attachEvent('on' + type, fn);
  } else {
    el.addEventListener(type, fn, false);
  }
}

function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this, args = arguments;
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);

    function later() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    }
  };
}

// https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708
var contains = function() {
  if (!global.document) {
    return true;
  }
  return global.document.documentElement.compareDocumentPosition ?
    function (a, b) {
      return !!(a.compareDocumentPosition(b) & 16);
    } :
    global.document.documentElement.contains ?
      function (a, b) {
        return a !== b && ( a.contains ? a.contains(b) : false );
      } :
      function (a, b) {
        while (b = b.parentNode) {
          if (b === a) {
            return true;
          }
        }
        return false;
      };
}

function createInViewport(container, debounceValue, failsafe) {
  var watches = createWatches();

  var scrollContainer = container === global.document.body ? global : container;
  var debouncedCheck = debounce(watches.checkAll(watchInViewport), debounceValue);

  addEvent(scrollContainer, 'scroll', debouncedCheck);

  if (scrollContainer === global) {
    addEvent(global, 'resize', debouncedCheck);
  }

  if (supportsMutationObserver) {
    observeDOM(watches, container, debouncedCheck);
  }

  // failsafe check, every X we check for visible images
  // usecase: a hidden parent containing eleements
  // when the parent becomes visible, we have no event that the children
  // became visible
  if (failsafe > 0) {
    setInterval(debouncedCheck, failsafe);
  }

  function isInViewport(elt, offset, cb) {
    if (!cb) {
      return isVisible(elt, offset);
    }

    var remote = createRemote(elt, offset, cb);
    remote.watch();
    return remote;
  }

  function createRemote(elt, offset, cb) {
    function watch() {
      watches.add(elt, offset, cb);
    }

    function dispose() {
      watches.remove(elt);
    }

    return {
      watch: watch,
      dispose: dispose
    };
  }

  function watchInViewport(elt, offset, cb) {
    if (isVisible(elt, offset)) {
      watches.remove(elt);
      cb(elt);
    }
  }

  function isVisible(elt, offset) {
    if (!elt) {
      return false;
    }

    if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) {
      return false;
    }

    // Check if the element is visible
    // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js
    if (!elt.offsetWidth || !elt.offsetHeight) {
      return false;
    }

    var eltRect = elt.getBoundingClientRect();
    var viewport = {};

    if (container === global.document.body) {
      viewport = {
        top: -offset,
        left: -offset,
        right: global.document.documentElement.clientWidth + offset,
        bottom: global.document.documentElement.clientHeight + offset
      };
    } else {
      var containerRect = container.getBoundingClientRect();
      viewport = {
        top: containerRect.top - offset,
        left: containerRect.left - offset,
        right: containerRect.right + offset,
        bottom: containerRect.bottom + offset
      };
    }

    // The element must overlap with the visible part of the viewport
    var visible =
      (
        eltRect.right >= viewport.left &&
        eltRect.left <= viewport.right &&
        eltRect.bottom >= viewport.top &&
        eltRect.top <= viewport.bottom
      );

    return visible;
  }

  return {
    container: container,
    isInViewport: isInViewport,
    _debounce: debounceValue,
    _failsafe: failsafe
  };
}

function createWatches() {
  var watches = [];

  function add(elt, offset, cb) {
    if (!isWatched(elt)) {
      watches.push([elt, offset, cb]);
    }
  }

  function remove(elt) {
    var pos = indexOf(elt);
    if (pos !== -1) {
      watches.splice(pos, 1);
    }
  }

  function indexOf(elt) {
    for (var i = watches.length - 1; i >= 0; i--) {
      if (watches[i][0] === elt) {
        return i;
      }
    }
    return -1;
  }

  function isWatched(elt) {
    return indexOf(elt) !== -1;
  }

  function checkAll(cb) {
    return function () {
      for (var i = watches.length - 1; i >= 0; i--) {
        cb.apply(this, watches[i]);
      }
    };
  }

  return {
    add: add,
    remove: remove,
    isWatched: isWatched,
    checkAll: checkAll
  };
}

function observeDOM(watches, container, cb) {
  var observer = new MutationObserver(watch);
  var filter = Array.prototype.filter;
  var concat = Array.prototype.concat;

  observer.observe(container, {
    childList: true,
    subtree: true,
    // changes like style/width/height/display will be catched
    attributes: true
  });

  function watch(mutations) {
    // some new DOM nodes where previously watched
    // we should check their positions
    if (mutations.some(knownNodes) === true) {
      setTimeout(cb, 0);
    }
  }

  function knownNodes(mutation) {
    var nodes = concat.call([],
      Array.prototype.slice.call(mutation.addedNodes),
      mutation.target
    );
    return filter.call(nodes, watches.isWatched).length > 0;
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lays.js/dist/lays.cjs.js":
/*!***********************************************!*\
  !*** ./node_modules/lays.js/dist/lays.cjs.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Lays.js helper functions.
 */

var extend = function extend(obj1, obj2) {
    for (var attrname in obj2) {
        obj1[attrname] = obj2[attrname];
    }
};

var inRange = function inRange(num) {
    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
    return num > from ? num <= to ? num : to : from;
};

var fillZero = function fillZero(cols) {
    return Array.apply(null, Array(cols)).map(function () {
        return 0;
    });
};

var getMax = function getMax(elements) {
    return elements.reduce(function (max, value) {
        return value > max ? value : max;
    }, 0);
};

function wait(func, delta) {
    var to = void 0;

    return function () {
        if (to) clearTimeout(to);

        to = setTimeout(func, delta);
    };
}

var LaysQueue = function LaysQueue(size) {
    var queue = [];

    size = size || Infinity;

    queue.fixedSize = size;

    queue.push = function () {
        [].push.apply(this, arguments);

        if (this.length <= this.fixedSize) return [];

        return this.splice(0, this.length - this.fixedSize);
    };

    queue.unshift = function () {
        [].unshift.apply(this, arguments);

        if (this.length <= this.fixedSize) return [];

        return this.splice(this.fixedSize);
    };

    return queue;
};

var LaysEvent = function LaysEvent() {
    var queue = {};

    return {
        fire: function fire(event) {
            var handlers = queue[event];

            if (typeof handlers === 'undefined') {
                return;
            }

            handlers.map(function (handler) {
                return handler();
            });
        },
        on: function on(event, callback) {
            if (typeof queue[event] === 'undefined') queue[event] = [];

            queue[event].push(callback);
        }
    };
};

var LaysEvent$1 = LaysEvent();

/**
 * Lays.js v1.1.0
 * @description Tiny masonry layout library.
 * @author BatenkovT
 */

/**
 * Returns new object with Lays methods.
 *
 * @module Lays
 * @param {Object} options Object with wrapper element and breakpoints
 */
var Lays = function Lays(options) {
    var parent = options.parent;

    if (!parent) return;

    var defaults = {
        prependItems: false,
        maxItems: undefined,
        breakpoints: {
            540: 2,
            720: 3,
            1024: 4,
            1280: 5
        }
    };

    extend(defaults.breakpoints, options.breakpoints);
    extend(defaults, options);

    var prependItems = defaults.prependItems,
        maxItems = defaults.maxItems,
        breakpoints = defaults.breakpoints;


    var pushType = prependItems ? 'unshift' : 'push';

    // all items
    var items = LaysQueue(maxItems);

    // items to add
    var newItems = LaysQueue(maxItems);

    // items to remove
    var restItems = [];

    var colsNum = 1;

    parent.classList.add('_laysContainer');

    /**
     * Public method. 
     * Add new DOM element to show in layout.
     *
     * @method add
     * @param {Object} el DOM element that should be added to masonry
     * @param {Boolean} [prepend=false] Add DOM element to the beginning or end of the array of elements
     */
    var add = function add(el) {
        el.classList.add('_laysItem');

        [].push.apply(restItems, items[pushType](el));
        newItems[pushType](el);
    };

    /**
     * Return next column to which masonry item should be added.
     *
     * @method next
     * @param {Object} item DOM element
     * @param {Array} columns Array with maximum column heights
     * @param {Number} col Current column number
     * @return {Number} col Next column number
     */
    var next = function next(item, columns, col) {
        columns[col] += item.offsetHeight;

        columns.map(function (height, index) {
            col = height < columns[col] ? index : col;
        });

        return col;
    };

    /**
     * Set masonry items position.
     *
     * @method setPosition
     */
    var setPosition = function setPosition() {
        var columns = fillZero(colsNum);
        var width = parent.offsetWidth / colsNum;
        var maxHeight = 0;
        var col = 0;

        items.map(function (item) {
            var left = width * col;
            var top = columns[col];

            item.style.cssText += 'position:absolute;width:' + width + 'px;-ms-transform:translate(' + left + 'px,' + top + 'px);transform:translate(' + left + 'px,' + top + 'px);';

            col = next(item, columns, col);
        });

        maxHeight = getMax(columns);

        parent.style.cssText += 'width:100%;height:' + maxHeight + 'px;';
    };

    /**
     * Append new (only new) masonry items to DOM.
     *
     * @method placeToDOM
     */
    var placeToDOM = function placeToDOM() {
        if (!newItems.length) return;

        var fragment = document.createDocumentFragment();

        restItems.map(function (item) {
            return parent.removeChild(item);
        });
        newItems.map(function (item) {
            return fragment.appendChild(item);
        });

        newItems.length = 0;
        restItems.length = 0;

        parent.appendChild(fragment);
    };

    /**
     * Set columns number depends on parent element width.
     *
     * @method setCols
     */
    var setCols = function setCols() {
        colsNum = 1;

        Object.keys(breakpoints).map(function (point) {
            if (parent.offsetWidth > point) colsNum = inRange(breakpoints[point], 1, 10);
        });
    };

    /**
     * Add window resize listener to recalculate layout.
     *
     * @method setResizeListener
     */
    var addResizeListener = function addResizeListener() {
        window.addEventListener('resize', wait(function () {
            LaysEvent$1.fire('resize');

            render();
        }, 200));
    };

    var init = function init() {
        [].map.call(parent.children, function (el) {
            return add(el);
        });
    };

    /**
     * Public method. 
     * Renders masonry layout.
     *
     * @method render
     */
    var render = function render() {
        placeToDOM();
        setCols();
        setPosition();
    };

    addResizeListener();
    init();

    // return public methods
    return {
        add: add,
        render: render,
        on: LaysEvent$1.on,
        _items: items
    };
};

module.exports = Lays;


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ })

/******/ });
//# sourceMappingURL=scripts.min.js.map